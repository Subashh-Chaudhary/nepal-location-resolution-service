// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

// Geographic point coordinates
type GeoPoint struct {
	// Latitude
	Lat float64 `json:"lat"`
	// Longitude
	Lon float64 `json:"lon"`
}

// Health status of the service
type HealthStatus struct {
	// Service status
	Status string `json:"status"`
	// Elasticsearch connection status
	Elasticsearch string `json:"elasticsearch"`
	// Service version
	Version string `json:"version"`
}

// Location entity with complete administrative hierarchy
type Location struct {
	// Unique identifier
	ID string `json:"id"`
	// Entity type: place, admin_boundary, poi, road
	EntityType string `json:"entityType"`
	// Primary name (may be in Nepali or English)
	Name string `json:"name"`
	// Nepali name
	NameNe *string `json:"nameNe,omitempty"`
	// English name
	NameEn *string `json:"nameEn,omitempty"`
	// Place type (e.g., village, town, city, hamlet)
	PlaceType *string `json:"placeType,omitempty"`
	// Administrative level (2=country, 4=province, 6=district, 7=municipality, 9=ward)
	AdminLevel *int `json:"adminLevel,omitempty"`
	// Geographic coordinates
	Location *GeoPoint `json:"location,omitempty"`
	// Ward number
	Ward *int `json:"ward,omitempty"`
	// Municipality name
	Municipality *string `json:"municipality,omitempty"`
	// Municipality name in Nepali
	MunicipalityNe *string `json:"municipalityNe,omitempty"`
	// District name
	District *string `json:"district,omitempty"`
	// District name in Nepali
	DistrictNe *string `json:"districtNe,omitempty"`
	// Province name
	Province *string `json:"province,omitempty"`
	// Province name in Nepali
	ProvinceNe *string `json:"provinceNe,omitempty"`
	// Country (always "Nepal")
	Country string `json:"country"`
	// Search relevance score
	Score float64 `json:"score"`
}

// Input for location search with optional parent validation
type LocationSearchInput struct {
	// Name of the place to search (supports fuzzy matching)
	Query string `json:"query"`
	// Optional: Expected ward number for validation
	Ward *int `json:"ward,omitempty"`
	// Optional: Expected municipality name for validation
	Municipality *string `json:"municipality,omitempty"`
	// Optional: Expected district name for validation
	District *string `json:"district,omitempty"`
	// Optional: Expected province name for validation
	Province *string `json:"province,omitempty"`
	// Maximum number of results to return (default: 10, max: 50)
	Limit *int `json:"limit,omitempty"`
}

// Response containing search results
type LocationSearchResponse struct {
	// List of matching locations
	Results []*Location `json:"results"`
	// Total number of matches found
	Total int `json:"total"`
	// Query execution time in milliseconds
	Took int `json:"took"`
	// Validation result if parent filters were provided
	Validation *ValidationResult `json:"validation,omitempty"`
}

type Query struct {
}

// Details about a validation mismatch
type ValidationMismatch struct {
	// Field name that mismatched
	Field string `json:"field"`
	// Expected value
	Expected string `json:"expected"`
	// Actual value found
	Actual *string `json:"actual,omitempty"`
}

// Validation result when parent filters are provided
type ValidationResult struct {
	// Whether the validation passed
	Valid bool `json:"valid"`
	// List of mismatches found during validation
	Mismatches []*ValidationMismatch `json:"mismatches"`
	// Validation message
	Message *string `json:"message,omitempty"`
}
